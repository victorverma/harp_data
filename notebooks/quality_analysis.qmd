---
title: "HARP Data Quality Analysis"
author: "Victor Verma"
date: 2024-08-02
date-format: iso
published-title: "Date Created"
output:
  html_document:
    embed-resources: true
    toc: true
    toc-location: left
    number_sections: true
    theme: united
---

```{r}
#| label: setup
#| include: false

library(arrow)
library(cowplot)
library(gridExtra)
library(here)
library(kableExtra)
library(knitr)
library(tidyverse)
library(vctrs)

harp_tbl <- read_parquet("../data/processed/harp_data.parquet")
```

In this analysis, we investigate quality issues in HARP data for the period `r str_c(format(range(harp_tbl$T_REC), "%F"), collapse = " to ")`. This data was obtained using the code in [this `git` repository](https://github.com/victorverma/harp_data).

# Use Only Solar Maximum Data

We flag times that lie within the lifetime of some HARP and are between the first and last such times.
```{r}
time_tbl <- harp_tbl %>%
  distinct(T_REC) %>%
  add_column(is_in_harp_lifetime = TRUE) %>%
  complete(T_REC = full_seq(T_REC, period = 720)) %>%
  mutate(is_in_harp_lifetime = coalesce(is_in_harp_lifetime, FALSE))
```

The majority of times are within some HARP lifetime, but a significant minority aren't.
```{r}
time_tbl %>%
  count(is_in_harp_lifetime, sort = TRUE) %>%
  mutate(prop = n / sum(n)) %>%
  kable(
    "html",
    digits = 2,
    col.names = c("Is in a HARP Lifetime?", "Count", "Proportion"),
    align = "crr",
    format.args = list(big.mark = ",")
  ) %>%
  kable_styling()
```

The sequence of times can be partitioned into runs such that within each run, either every time is in some HARP lifetime or no time is in some HARP lifetime. For each run, we compute its start and end times and its duration.
```{r}
#| message: false

time_rle_obj <- rle(time_tbl$is_in_harp_lifetime)
time_summary_tbl <- time_tbl %>%
  add_column(
    run_id = rep(seq_along(time_rle_obj$values), times = time_rle_obj$lengths)
  ) %>%
  group_by(run_id, is_in_harp_lifetime) %>%
  summarize(
    start_time = min(T_REC),
    end_time = max(T_REC),
    days_elapsed = difftime(max(T_REC), min(T_REC), units = "days"),
    num_times = length(T_REC)
  ) %>%
  ungroup() %>%
  select(!run_id)
```

In the plot below, each dot represents one run of times. A run is blue if it consists exclusively of times that lie within the lifetime of some HARP; a run is red if it only contains times that do not have that property. The first coordinate of a dot is the start time of the corresponding run, while the second coordinate is the run's duration in days. Red runs should not be used as there is no HARP data for them and no way to impute it. It seems reasonable to train a model with at least a few months' worth of data; there are only two blue runs that could be divided into training sets with that much data. Both of those runs correspond to solar maxima.
```{r}
time_summary_tbl %>%
  mutate(days_elapsed = as.double(days_elapsed)) %>%
  ggplot(aes(start_time, days_elapsed, color = is_in_harp_lifetime)) +
  geom_point() +
  scale_y_log10() +
  scale_color_discrete(
    labels = c(
      `TRUE` = "Every Time Is in a HARP Lifetime",
      `FALSE` = "No Time Is in a HARP Lifetime"
    )
  ) +
  labs(x = "Run Start Time", y = "Run Length (Days)", color = "") +
  theme_bw() +
  theme(legend.position = "top")
```

The table below displays the five longest runs that have HARP data at each time. As stated above, only two runs are long enough that they can be carved into multiple reasonably-sized training sets.
```{r}
time_summary_tbl %>%
  filter(is_in_harp_lifetime) %>%
  select(!is_in_harp_lifetime) %>%
  slice_max(days_elapsed, n = 5) %>%
  mutate(days_elapsed = as.double(days_elapsed)) %>%
  kable(
    "html",
    digits = 2,
    col.names = c(
      "Run Start Time", "Run End Time",
      "Run Length (Days)", "Run Length (Times)"
    ),
    align = "ccrr",
    format.args = list(big.mark = ",")
  ) %>%
  kable_styling()
```

In the sequel, we will only consider times from the longest run.
```{r}
harp_tbl <- harp_tbl %>%
  filter(
    between(
      T_REC,
      as_datetime("2010-05-19 01:12:00"), as_datetime("2016-12-10 00:00:00")
    )
  )
```


